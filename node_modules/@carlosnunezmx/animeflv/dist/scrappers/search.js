"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Search = exports.Emmision = void 0;
const config_js_1 = __importDefault(require("../config.js"));
const main_page_js_1 = require("./main_page.js");
const errors_js_1 = require("../errors.js");
const fetch_js_1 = require("./fetch.js");
// I tried it - I give up for filtering...
function timeout(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
async function sleep(fn, ...args) {
    await timeout(3000);
    return fn(...args);
}
var Emmision;
(function (Emmision) {
    Emmision[Emmision["OnGoing"] = 0] = "OnGoing";
    Emmision[Emmision["Finished"] = 1] = "Finished";
    Emmision[Emmision["CommingSoon"] = 2] = "CommingSoon";
})(Emmision || (exports.Emmision = Emmision = {}));
async function Search(Query) {
    if (!Query)
        throw new errors_js_1.ValidationError("Se requiere una Query para buscar", { Query: true });
    if (typeof Query === 'string') {
        const $ = await (0, fetch_js_1.fetchResource)({ resource: config_js_1.default.baseURL + config_js_1.default.search + '?q=' + Query });
        return (0, main_page_js_1.GetNewSeries)($);
    }
    const browse = new URLSearchParams();
    if (Query.year)
        if (typeof Query.year === 'number')
            browse.set('year[]', Query.year.toString());
        else
            Query.year.forEach(year => browse.append('year[]', year.toString()));
    if (Query.type)
        if (typeof Query.type === 'string')
            browse.set('type[]', Query.type);
        else
            Query.type.forEach(type => browse.append('type[]', type));
    if (Query.order)
        browse.set('order', Query.order);
    if (Query.status)
        if (typeof Query.status === 'number')
            browse.set('status[]', (Query.status + 1).toString());
        else
            Query.status.forEach(status => browse.append('status[]', (status + 1).toString()));
    if (Query.page)
        browse.set('page', Query.page.toString());
    // Procesar peticion
    const $ = await (0, fetch_js_1.fetchResource)({
        resource: config_js_1.default.baseURL + config_js_1.default.search + '?' + browse.toString()
    });
    const Series = await (0, main_page_js_1.GetNewSeries)($);
    if (process.env["DEBUG"])
        console.log("[DEBUG] = Got", config_js_1.default.search + browse.toString());
    const $Pagination = $.querySelectorAll('.pagination li a:not([rel])');
    if ($Pagination.length == 0)
        throw new errors_js_1.HTML_PARSING_ERROR('Pagination Items', 'episode.ts', 'Search: Query{}', '$Pagination');
    let Pages = {
        first: Number($Pagination[0].innerText ?? "0"),
        last: Number($Pagination.pop()?.innerHTML ?? "0")
    };
    if (!Query.allCatalog)
        return { Series, Pages };
    let container = await Format(Series, Pages, Query);
    Series.concat(container);
    return Series;
}
exports.Search = Search;
async function Format(Series, Pages, Query) {
    if (typeof Query === "string")
        return Series;
    for (let i = Pages.first; i <= Pages.last; i++) {
        const url = "/browse?" + new URLSearchParams({
            page: i.toString()
        }).toString();
        if (process.env["DEBUG"])
            console.info("[DEGUB] > Getting", url);
        if (!Query.wait) {
            const $$ = await (0, fetch_js_1.fetchResource)({ resource: config_js_1.default.baseURL + url });
            const series = await (0, main_page_js_1.GetNewSeries)($$);
            Series.push(...series);
            continue;
        }
        await timeout((Query.wait.seconds * i) * 1000);
        const $$ = await (0, fetch_js_1.fetchResource)({ resource: config_js_1.default.baseURL + url });
        const series = await (0, main_page_js_1.GetNewSeries)($$);
        Series.push(...series);
        Query.wait?.onPage(i);
    }
    return Series;
}
